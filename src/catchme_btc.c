/*
*******************************************************************************    
*   BOLOS Enclave Samples
*   (c) 2017 Ledger
*   
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*   Unless required by applicable law or agreed to in writing, software
*   distributed under the License is distributed on an "AS IS" BASIS,
*   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*   limitations under the License.
********************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "bolos.h"

#define ACTION_GENERATE 0x01
#define ACTION_PROCESS 0x02
#define ACTION_EXTRACT 0x03

static unsigned char const BASE58ALPHABET[] = {
    '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};

unsigned int encode_base58(unsigned char *in, unsigned int length,
                           unsigned char *out, unsigned int maxoutlen) {
    unsigned char tmp[164];
    unsigned char buffer[164];
    unsigned char j;
    unsigned char startAt;
    unsigned char zeroCount = 0;
    if (length > sizeof(tmp)) {
        return 0;
    }
    memmove(tmp, in, length);
    while ((zeroCount < length) && (tmp[zeroCount] == 0)) {
        ++zeroCount;
    }
    j = 2 * length;
    startAt = zeroCount;
    while (startAt < length) {
        unsigned short remainder = 0;
        unsigned char divLoop;
        for (divLoop = startAt; divLoop < length; divLoop++) {
            unsigned short digit256 = (unsigned short)(tmp[divLoop] & 0xff);
            unsigned short tmpDiv = remainder * 256 + digit256;
            tmp[divLoop] = (unsigned char)(tmpDiv / 58);
            remainder = (tmpDiv % 58);
        }
        if (tmp[startAt] == 0) {
            ++startAt;
        }
        buffer[--j] = (unsigned char)BASE58ALPHABET[remainder];
    }
    while ((j < (2 * length)) && (buffer[j] == BASE58ALPHABET[0])) {
        ++j;
    }
    while (zeroCount-- > 0) {
        buffer[--j] = BASE58ALPHABET[0];
    }
    length = 2 * length - j;
    if (maxoutlen < length) {
        return 0;
    }
    memmove(out, (buffer + j), length);
    return length;
}

void write_u32(uint8_t *buffer, uint32_t value) {
	buffer[0] = (value >> 24);
	buffer[1] = (value >> 16);
	buffer[2] = (value >> 8);
	buffer[3] = (value & 0xff);
}

uint32_t read_u32(uint8_t *buffer) {
	return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
}

// Return a public key for ECDH, proving that the public key has been generated by that code 
// on the Trusted Computing Base
void handleGenerate(uint8_t *parameters, uint32_t parametersLength) {
	uint8_t result[400];
	uint8_t secretData[100];
	uint8_t antireplayRef[50];
	uint32_t antireplayRefSize;
	uint32_t size;
	uint8_t privateKeyData[32];
	uint32_t offset = 0;
	uint32_t offsetSecret = 0;
	bls_ecfp_public_key_t publicKey = {0};
	bls_ecfp_private_key_t privateKey = {0};	
	// Generate an antireplay counter 
	antireplayRefSize = bls_antireplay_create(antireplayRef, sizeof(antireplayRef));
	if (antireplayRefSize == 0) {
		bls_debug("Failed to create antireplay\n");
		return;
	}
	// Generate a keypair
  bls_ecdsa_init_private_key(BLS_CURVE_256K1, NULL, 0, &privateKey);
	bls_ecdsa_init_public_key(BLS_CURVE_256K1, NULL, 0, &publicKey);
	bls_ecfp_generate_pair(BLS_CURVE_256K1, &publicKey, &privateKey, privateKeyData);
	// Return public data
	// ephemeral public key (app data)
	bls_ecfp_get_public_component(&publicKey, result + offset);
	offset += 65;
	// endorsement public key 1 || endorsement public key 1 signature || key1 signature of app data 
	size = bls_endorsement_get_public_key(BLS_ENDORSEMENT_KEY1, result + offset, sizeof(result) - offset);
	if (size == 0) {
		bls_antireplay_delete(antireplayRef, antireplayRefSize);
		bls_debug("Failed to get endorsement public key 1\n");
		return;
	}
	offset += size;
	size = bls_endorsement_get_certificate(BLS_ENDORSEMENT_KEY1, result + offset, sizeof(result) - offset);
	if (size == 0) {
		bls_antireplay_delete(antireplayRef, antireplayRefSize);
		bls_debug("Failed to get certificate for endorsement key 1\n");
		return;
	}
	offset += size;
	size = bls_endorsement_key1_sign_data(result, 65, result + offset, sizeof(result) - offset);
	if (size == 0) {
		bls_antireplay_delete(antireplayRef, antireplayRefSize);
		bls_debug("Failed to sign endorsement data\n");
		return;
	}
	offset += size;
	// Add processing data
	// uint32 processing data size || wrap(ACTION_GENERATE || uint32 size of counter reference || counter reference || private key)
	secretData[offsetSecret++] = ACTION_GENERATE;
	write_u32(secretData + offsetSecret, antireplayRefSize);
	offsetSecret += 4;
	memmove(secretData + offsetSecret, antireplayRef, antireplayRefSize);
	offsetSecret += antireplayRefSize;
	memmove(secretData + offsetSecret, privateKeyData, 32);
	offsetSecret += 32;
	size = bls_wrap(BLS_SCOPE_APPLICATION, secretData, offsetSecret, result + offset + 4, sizeof(result) - offset - 4);
	write_u32(result + offset, size);
	offset += size + 4;
	bls_set_return(result, offset);
}

// Perform the ECDH and bind the secret returned by the remote party to this enclave
void handleProcess(uint8_t *parameters, uint32_t parametersLength) {
	// uint32 processing data size || wrap(ACTION_GENERATE || uint32 size of counter reference || counter reference || private key)
	// ephemeral public key || sodium_box_ecdh(privateKey)
	uint8_t result[200];
	uint8_t secretData[100];
	uint8_t secret[32];
	uint8_t privateKeyData[32];
	uint32_t antireplayRefSize;	
	uint32_t offset = 0;
	uint32_t offsetSecret = 0;
	uint32_t wrappedSize;
	uint32_t secretDataSize;
	uint32_t size;
	bls_ecfp_private_key_t privateKey = {0};
	wrappedSize = read_u32(parameters + offset);
	offset += 4;
	// Extract the previous context, make sure it's only run once by removing the antireplay reference
	secretDataSize = bls_unwrap(BLS_SCOPE_APPLICATION, parameters + offset, wrappedSize, secretData, sizeof(secretData));
	if (secretData[offsetSecret++] != ACTION_GENERATE) {
		bls_debug("Invalid data\n");
		return;
	}
	antireplayRefSize = read_u32(secretData + offsetSecret);
	offsetSecret += 4;
	if (!bls_antireplay_delete(secretData + offsetSecret, antireplayRefSize)) {
		bls_debug("Failed to delete antireplay reference\n");
		return;
	}
	offsetSecret += antireplayRefSize;
	// Recover the session secret and the private key
	bls_ecdsa_init_private_key(BLS_CURVE_256K1, secretData + offsetSecret, 32, &privateKey);
	offset += wrappedSize;
	size = bls_ecdh(&privateKey, BLS_ECDH_HASHED, parameters + offset, secret);
	if (size == 0) {
		bls_debug("ECDH failed\n");
		return;
	}
	offset += 65;
	if (crypto_secretbox_open_easy(privateKeyData, parameters + offset + crypto_secretbox_NONCEBYTES, parametersLength - offset - crypto_secretbox_NONCEBYTES, parameters + offset, secret)) {
		bls_debug("Secret recovery failed\n");
		return;
	}
	offset = 0;
	secretData[offset++] = ACTION_PROCESS;
	memmove(secretData + offset, privateKeyData, 32);
	offset += 32;
	size = bls_wrap(BLS_SCOPE_APPLICATION, secretData, offset, result, sizeof(result));
	bls_set_return(result, size);
}

void handleExtract(uint8_t *parameters, uint32_t parametersLength) {
	uint8_t tmp[25];
	uint8_t publicKeyData[65];
	uint8_t result[50];
	uint8_t privateBlob[33];
	uint32_t secretDataSize;
	uint32_t addressLength;
	bls_ecfp_public_key_t publicKey = {0};
	bls_ecfp_private_key_t privateKey = {0};	
  union {
		bls_sha256_t shasha;
		bls_ripemd160_t riprip;
	} u;
	bls_ripemd160_t ripemd;	
	// Recover the private key, coonvert it to a public key
	secretDataSize = bls_unwrap(BLS_SCOPE_APPLICATION, parameters, parametersLength, privateBlob, sizeof(privateBlob));
	if (privateBlob[0] != ACTION_PROCESS) {
		bls_debug("Invalid data\n");
		return;		
	}
  bls_ecdsa_init_private_key(BLS_CURVE_256K1, privateBlob + 1, 32, &privateKey);
	bls_ecdsa_init_public_key(BLS_CURVE_256K1, NULL, 0, &publicKey);
	bls_ecfp_generate_pair(BLS_CURVE_256K1, &publicKey, &privateKey, NULL);
	bls_ecfp_get_public_component(&publicKey, publicKeyData);
	// And return the associated Bitcoin address
 	publicKeyData[0] = ((publicKeyData[64] & 1) ? 0x03 : 0x02);
	bls_sha256_init(&u.shasha);
	bls_hash(&u.shasha.header, BLS_LAST, publicKeyData, 33, privateBlob);
	bls_ripemd160_init(&u.riprip);
	bls_hash(&u.riprip.header, BLS_LAST, privateBlob, 32, tmp + 1);
	tmp[0] = 0;
	bls_sha256_init(&u.shasha);
	bls_hash(&u.shasha.header, BLS_LAST, tmp, 21, privateBlob);
	bls_sha256_init(&u.shasha);
	bls_hash(&u.shasha.header, BLS_LAST, privateBlob, 32, privateBlob);
	memmove(tmp + 21, privateBlob, 4);
	addressLength = encode_base58(tmp, sizeof(tmp), result, sizeof(result));
	bls_set_return(result, addressLength);	
}


int main(int argc, char **argv) {
	unsigned char parameters[400];
	uint32_t parametersLength;
	parametersLength = bls_get_input_parameters_length();
	bls_copy_input_parameters(parameters, 0, parametersLength);
	switch(parameters[0]) {
		case ACTION_GENERATE:
			handleGenerate(parameters + 1, parametersLength - 1);
			break;
		case ACTION_PROCESS:
			handleProcess(parameters + 1, parametersLength - 1);
			break;
		case ACTION_EXTRACT:
			handleExtract(parameters + 1, parametersLength - 1);
			break;
		default:
			bls_debug("Unsupported request\n");
			return 0;
	}
}

